import auro.system { void error(string); }

import aulang.parser {
  type Node as Node {
    string tp;
    string val;
    int line;

    int len ();
    Node child (int);
  }
  Node parse (string);
}

import auro.buffer { type buffer; }
import aulang.writer {
  type Writer {
    new ();
    void byte (int);
    void num (int);
    void str (string);
    void rawstr (string);
    buffer tobuffer ();
  }
}

// =============================== //
//               Types             //
// =============================== //

import auro.utils.stringmap (any) {
  type `` as Map {
    new ();
    any? get (string);
    void set (string, any);
  }
}

struct Pair { string k; any v; }
import auro.utils.arraylist (Pair) {
  type `` as `Pair[]` {
    new ();
    int len();
    Pair get (int);
    void push (Pair);
  }
}

struct Item {
  string tp;
  string name;
  int line;
}

struct Module {
  int id;
  string kind;
  string name;
  any argument;
  Pair[] items;
  int line;

  void set (Module this, string k, any v) {
    this.items.push(new Pair(k, v));
  }
}

struct Type {
  int id;
  string name;
  any mod;
}

import auro.utils.arraylist (Module) {
  type `` as `Module[]` {
    new ();
    int len();
    Module get (int);
    void set (int, Module);
    void push (Module);
    void remove (int);
  }
}

import auro.utils.arraylist (Type) {
  type `` as `Type[]` {
    new ();
    int len();
    Type get (int);
    void push (Type);
  }
}

struct Compiler {
  string filename;
  Node program;
  Map items;
  Writer writer;

  Module[] modules;
  Type[] types;
  any exported;

  any getItem (Compiler this, any a) {
    if (a is Item) {
      Item item = a as Item;
      any? _a = this.items[item.name];
      if (_a.isnull()) this.error(item.tp + " " + item.name + " not found", item.line);
      a = _a.get();

      string atp = "unknown";
      if (a is Module) atp = "module";
      if (a is Type) atp = "type";
      if ((item.tp == atp) || (item.tp == "")) return a;
      this.error(item.name + " is a " + atp, item.line);
    }
    if (a is string) {
      string k = a as string;
      any? _a = this.items[k];
      if (_a.isnull()) this.error(k + " not found", 0-1);
      a = _a.get();
    }
    return a;
  }

  Module Module (Compiler this) {
    Module mod = new Module(this.modules.len(), "", "", false as any, new Pair[](), 0);
    this.modules.push(mod);
    return mod;
  }

  Type Type (Compiler this, string name, any mod) {
    Type t = new Type(this.types.len(), name, mod);
    this.types.push(t);
    return t;
  }

  void error (Compiler this, string msg, int line) {
    error(msg + ", at " + this.filename + " at line " + itos(line));
  }
}

// =============================== //
//             Compiler            //
// =============================== //

buffer compile (Node program, string filename) {
  Compiler c = new Compiler (
    filename, program,
    new Map(), new Writer(),
    new Module[](), new Type[](),
    false as any
  );
  Module exported = c.Module(); // First module is the exported module
  exported.kind = "define";

  int i = 0;
  while (i < c.program.len()) {
    Node node = c.program.child(i);
    i = i+1;

    if (node.tp == "module-assign") {
      Module mod = c.Module();
      mod.line = node.line;
      c.items[node.val] = mod as any;

      Node vnode = node.child(0);

      if (vnode.tp == "import") {
        mod.kind = "import";
        mod.name = vnode.val;
      }
      else c.error(vnode.tp + " module expression", vnode.line);
    }

    else if (node.tp == "module-def") {
      Module mod = c.Module();
      mod.kind = "define";
      mod.line = node.line;
      c.items[node.val] = mod as any;

      Node body = node.child(0);
      int j = 0;
      while (j < body.len()) {
        Node inode = body.child(j);
        string alias = inode.child(0).val;
        any item = c.getItem(inode.val as any);
        mod[alias] = item;
        j = j+1;
      }
    }

    else if (node.tp == "type-assign") {
      string mod = node.child(0).val;
      string name = node.child(1).val;
      Type t = c.Type(name, new Item("module", mod, node.line) as any);
      c.items[node.val] = t as any;
    }

    else if (node.tp == "export") {
      node child = node.child(0);
      if (exported.items.len() > 0)
        c.error("Export overrides public items", node.line);
      if (!(c.exported is bool))
        c.error("Export overrides previous export", node.line);

      if (child.tp == "item") {
        c.exported = new Item("module", child.val, node.line) as any;
      } else c.error("Cannot export " + child.tp, node.line);
    }
  }

  // Define export
  if (!(c.exported is bool)) {
    Module mod = c.getItem(c.exported) as Module;
    c.modules[0] = mod;
    int i = mod.id;
    c.modules.remove(i);
    mod.id = 0;
    while (i < c.modules.len()) {
      c.modules[i].id = i;
      i = i+1;
    }
  }

  return getBuffer(c);
}

// =============================== //
//              Writer             //
// =============================== //

void writeModules (Compiler c) {
  Writer w = c.writer;
  Module[] mods = c.modules;

  w.num(mods.len());

  int i = 0;
  while (i < mods.len()) {
    Module mod = mods[i];
    i = i+1;
    if (mod.kind == "import") {
      w.byte(1);
      w.str(mod.name);
    } else if (mod.kind == "define") {
      w.byte(2);
      w.num(mod.items.len());
      int j = 0;
      while (j < mod.items.len()) {
        Pair p = mod.items[j];
        any item = c.getItem(p.v);
        int k, id;
        if (item is Module) {
          k = 0; id = (item as Module).id;
        } else if (item is Type) {
          k = 1; id = (item as Type).id;
        } /*else if (p.v is Function) {
          k = 2; id = (p.v as Function).id;
        }*/ else error("???");
        w.byte(k);
        w.num(id);
        w.str(p.k);
        j = j+1;
      }
    }
    else error("What am i doing?");
  }
}

void writeTypes (Compiler c) {
  Writer w = c.writer;

  w.num(c.types.len());

  int i = 0;
  while (i < c.types.len()) {
    Type t = c.types[i];
    i = i+1;
    Module mod = c.getItem(t.mod) as Module;
    w.num(mod.id + 1);
    w.str(t.name);
  }
}

buffer getBuffer (Compiler c) {
  Writer w = c.writer;

  w.rawstr("Auro 0.6");
  w.byte(0);

  writeModules(c);
  writeTypes(c);
  w.num(0); // Functions
  w.num(0); // Constants
  w.num(0); // Metadata

  return w.tobuffer();
}

// =============================== //
//             Interface           //
// =============================== //

import auro.io {
  type file;
  type mode as filemode;
  filemode w ();
  file open (string, filemode);
  void write (file, buffer);
}

import aulang.util { string readall (string); }

void main () {
  string src = readall("test.au");
  buffer buf = compile(parse(src), "test.au");
  file f = open("out", w());
  write(f, buf);
}