
import auro.system {
  void error (string);
}

import auro.int.bit {
  int shl (int, int);
  int and (int, int);
  int or (int, int);
}

import auro.buffer {
  type buffer;
  int size (buffer) as bufsize;
  buffer `new` (int size) as newbuf;
  int get (buffer, int pos) as bufget;
  void set (buffer, int pos, int val) as bufset;
}

import auro.string {
  string `new` (buffer) as newstr;
}

export int as MyInt;

import auro.io {
  type file; 
  type mode;
  mode r ();
  file open (string, mode);
  buffer read (file, int);
  bool eof (file);
}

import auro.utils.arraylist (string) {
  type `` as `string[]` {
    new ();
    int len();
    string get (int);
    void push (string);
  }
}

import auro.utils.arraylist (Item) {
  type `` as `Item[]` {
    new ();
    int len();
    Item get (int);
    void push (Item);
  }
}

import auro.utils.arraylist (_Item) {
  type `` as `_Item[]` {
    new ();
    int len();
    _Item get (int);
    void push (_Item);
  }
}

private struct Reader {
  file file;
  buffer buffer;
  int p;

  bool eof (Reader this) {
    return (this.p >= bufsize(this.buffer)) && eof(this.file);
  }

  int byte (Reader this) {
    while (this.p >= bufsize(this.buffer) && !eof(this.file)) {
      this.buffer = read(this.file, 512);
      this.p = this.p - 512;
    }
    if (this.p < bufsize(this.buffer)) {
      int b = bufget(this.buffer, this.p);
      this.p = this.p + 1;
      return b;
    }
    error("End of file");
  }

  int int (Reader this) {
    int n = 0;
    int b = this.byte();
    while (and(b, 128) > 0) {
      n = or(shl(n, 7), and(b, 127));
      b = this.byte();
    }
    return or(shl(n, 7), and(b, 127));
  }

  string str (Reader this) {
    int len = this.int();
    buffer buf = newbuf(len);
    int i = 0;
    while (i < len) {
      int b = this.byte();
      bufset(buf, i, b);
      i = i+1;
    }
    return newstr(buf);
  }

  void skip (Reader this, int n) { this.p = this.p + n; }
}



struct MapPair { string k; Item v; }

import auro.utils.stringmap (Item) {
  type `` as Map {
    new ();
    Item? get (string);
    void set (string, Item);
  }

  type iterator {
    MapPair? next ();
  }
  iterator `new\x1diterator` (Map) as newIter;
}






// =============================== //
//             Compiler            //
// =============================== //

private struct Item {
  int kind;
  string mod;
  string name;
  _Item[] ins;
  _Item[] outs;
}

private type _Item (Item);
export _Item as Item;

private struct Module {
  string name;
  Map map;
}

private struct ItemDef {
  int kind;
  int id;
  string name;
}

void makeModule (Module m, Reader r) {
  r.skip(9); // "Auro 0.6\n"

  string[] mods = new string[]();
  mods.push(""); // argument module

  // Skip the first one (Will be parsed on it's own)
  int modc = r.int() - 1;

  // The export module is not define, abort
  if (!(r.byte() == 2)) return;

  ItemDef[] items = new ItemDef[]();

  int itemc = r.int();
  while (itemc > 0) {
    itemc = itemc-1;
    int k = r.int();
    int id = r.int();
    string name = r.str();
    items.push(new ItemDef(k, id, name));
  }

  while (modc > 0) {
    modc = modc - 1;
    string s = "";

    int k = r.byte();

    if (k == 1) {
      // Import, the only useful
      s = r.str();
    } else if (k == 2) {
      // Define, ignore all items
      int x = r.int();
      while (x > 0) {
        x = x-1;
        r.int(); // kind
        r.int(); // id
        r.str(); // name
      }
    } else if (k == 3) {
      // Use module
      r.int(); // base module
      r.str(); // item name
    } else if (k == 4) {
      r.int(); // functor
      r.int(); // argument
    }

    mods.push(s);
  }

  int typec = r.int();
  int i = 0;
  while (i < typec) {
    string mod = mods[r.int() - 2];
    string name = r.str();

    int j = 0;
    while (j < items.len()) {
      ItemDef item = items[j];
      if ((item.kind == 1) && (item.id == i)) {
        if (mod == "") {
          mod = m.name;
          name = item.name;
        }
        m.map[item.name] = new Item(1, mod, name, new _Item[](), new _Item[]());
      }
      j = j+1;
    }
    i = i+1;
  }
}

struct Searcher {
  Module[] list;

  void insert (Searcher this, string name) {
    file f = open(name, r());
    Reader reader = new Reader(f, read(f, 512), 0);
    Module mod = new Module(name, new Map());
    makeModule(mod, reader);
    this.list.push(mod);
  }

  _Item? get (Searcher this, string name) {
    int i = this.list.len() - 1;
    while (i >= 0) {
      Module mod = this.list[i];
      Item? it = mod.map[name];
      if (!it.isnull()) return (it.get() as _Item) as _Item?;
      i = i-1;
    }
    return new _Item?();
  }
}

private Searcher _new () {
  return new Searcher(new Module[]());
}

export _new as `new\x1dSearcher`;

int _kind (_Item _) { return (_ as Item).kind; }
export _kind as `kind\x1dget\x1dItem`;
string _mod (_Item _) { return (_ as Item).mod; }
export _mod as `mod\x1dget\x1dItem`;
string _name (_Item _) { return (_ as Item).name; }
export _name as `name\x1dget\x1dItem`;
Item[] _ins (_Item _) { return (_ as Item).ins; }
export _ins as `ins\x1dget\x1dItem`;
Item[] _outs (_Item _) { return (_ as Item).outs; }
export _outs as `outs\x1dget\x1dItem`;

void main () {
  Searcher search = _new();
  search.insert("search");
  Module mod = search.list[0];
  println("module '" + mod.name + "'");

  iterator iter = newIter(mod.map);
  MapPair? next = iter.next();
  while (!next.isnull()) {
    MapPair pair = next.get();
    string k = pair.k;
    Item item = pair.v;
    if (item.kind == 1) {
      println("type " + k + " = " + item.mod + "." + item.name);
    }
    next = iter.next();
  }
}