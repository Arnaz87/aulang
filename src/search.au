
import auro.system {
  void error (string);
}

import auro.int.bit {
  int shl (int, int);
  int and (int, int);
  int or (int, int);
}

import auro.buffer {
  type buffer;
  int size (buffer) as bufsize;
  buffer `new` (int size) as newbuf;
  int get (buffer, int pos) as bufget;
  void set (buffer, int pos, int val) as bufset;
}

import auro.string {
  string `new` (buffer) as newstr;
}

export int as MyInt;

import auro.io {
  type file; 
  type mode;
  mode r ();
  file open (string, mode);
  buffer read (file, int);
  bool eof (file);
}

import auro.utils.arraylist (string) {
  type `` as `string[]` {
    new ();
    int len();
    string get (int);
    void push (string);
  }
}

import auro.utils.arraylist (Item) {
  type `` as `Item[]` {
    new ();
    int len();
    Item get (int);
    void push (Item);
  }
}

import auro.utils.arraylist (_Item) {
  type `` as `_Item[]` {
    new ();
    int len();
    _Item get (int);
    void push (_Item);
  }
}

private struct Reader {
  file file;
  buffer buffer;
  int p;

  bool eof (Reader this) {
    return (this.p >= bufsize(this.buffer)) && eof(this.file);
  }

  int byte (Reader this) {
    while (this.p >= bufsize(this.buffer) && !eof(this.file)) {
      this.buffer = read(this.file, 512);
      this.p = this.p - 512;
    }
    if (this.p < bufsize(this.buffer)) {
      int b = bufget(this.buffer, this.p);
      this.p = this.p + 1;
      return b;
    }
    error("End of file");
  }

  int int (Reader this) {
    int n = 0;
    int b = this.byte();
    while (and(b, 128) > 0) {
      n = or(shl(n, 7), and(b, 127));
      b = this.byte();
    }
    return or(shl(n, 7), and(b, 127));
  }

  string str (Reader this) {
    int len = this.int();
    buffer buf = newbuf(len);
    int i = 0;
    while (i < len) {
      int b = this.byte();
      bufset(buf, i, b);
      i = i+1;
    }
    return newstr(buf);
  }

  void skip (Reader this, int n) { this.p = this.p + n; }
}



private struct MapPair { string k; Item v; }

import auro.utils.stringmap (Item) {
  type `` as Map {
    new ();
    Item? get (string);
    void set (string, Item);
  }

  type iterator {
    MapPair? next ();
  }
  iterator `new\x1diterator` (Map) as newIter;
}






// =============================== //
//             Compiler            //
// =============================== //

private struct Item {
  int kind;
  string mod;
  string name;
  _Item[] ins;
  _Item[] outs;

  bool is_valid (Item this) { return !(this.mod == ""); }
  string tostr (Item this) { return this.mod + "." + this.name; }
}

private type _Item (Item);
export _Item as Item;

private struct Module {
  string name;
  Map map;
}

private struct ItemDef {
  int kind;
  int id;
  string name;
}

// TODO: Optimize, it's doing about 3 more loops than necessary
void makeModule (Module m, Reader r) {

  r.skip(9); // "Auro 0.6\n"

  string[] mods = new string[]();
  mods.push(""); // argument module

  // Skip the first one (Will be parsed on it's own)
  int modc = r.int() - 1;

  // The export module is not define, abort
  if (!(r.byte() == 2)) return;

  ItemDef[] items = new ItemDef[]();

  int itemc = r.int();
  while (itemc > 0) {
    itemc = itemc-1;
    int k = r.int();
    int id = r.int();
    string name = r.str();
    items.push(new ItemDef(k, id, name));
  }

  while (modc > 0) {
    modc = modc - 1;
    string s = "";

    int k = r.byte();

    if (k == 1) {
      // Import, the only useful
      s = r.str();
    } else if (k == 2) {
      // Define, ignore all items
      int x = r.int();
      while (x > 0) {
        x = x-1;
        r.int(); // kind
        r.int(); // id
        r.str(); // name
      }
    } else if (k == 3) {
      // Use module
      r.int(); // base module
      r.str(); // item name
    } else if (k == 4) {
      r.int(); // functor
      r.int(); // argument
    }

    mods.push(s);
  }

  Item types = new Item[]();

  int typec = r.int();
  int i = 0;
  while (i < typec) {
    string mod = mods[r.int() - 2];
    string name = r.str();

    Item item = new Item(1, mod, name, new _Item[](), new _Item[]());
    types.push(item);

    i = i+1;
  }

  int i = 0;
  while (i < items.len()) {
    ItemDef def = items[i];
    if (def.kind == 1) {
      Item item = types[def.id];
      if (item.mod == "") {
        item.mod = m.name;
        item.name = def.name;
      }
      m.map[def.name] = item;
    }
    i = i+1;
  }

  Item funs = new Item[]();

  int func = r.int();
  int i = 0;
  while (i < func) {
    int kind = r.int();

    Item item = new Item(2, m.name, "", new _Item[](), new _Item[]());

    int inc = r.int();
    while (inc > 0) {
      item.ins.push(types[r.int()] as _Item);
      inc = inc-1;
    }

    int outc = r.int();
    while (outc > 0) {
      item.outs.push(types[r.int()] as _Item);
      outc = outc-1;
    }

    if (kind > 1) r.str(); // Skip name

    funs.push(item);

    i = i+1;
  }


  int i = 0;
  while (i < items.len()) {
    ItemDef def = items[i];
    if (def.kind == 2) {
      Item item = funs[def.id];

      int j = 0;
      while (j < item.ins.len()) {
        if (!(item.ins[j] as Item).is_valid())
          goto next;
        j = j+1;
      }

      int j = 0;
      while (j < item.outs.len()) {
        if (!(item.outs[j] as Item).is_valid())
          goto next;
        j = j+1;
      }

      item.name = def.name;
      m.map[def.name] = item;
    }

    next:
    i = i+1;
  }
}

struct Searcher {
  Module[] list;

  void insert (Searcher this, string name) {
    file f = open(name, r());
    Reader reader = new Reader(f, read(f, 512), 0);
    Module mod = new Module(name, new Map());
    makeModule(mod, reader);
    this.list.push(mod);
  }

  _Item? get (Searcher this, string name) {
    int i = this.list.len() - 1;
    while (i >= 0) {
      Module mod = this.list[i];
      Item? it = mod.map[name];
      if (!it.isnull()) return (it.get() as _Item) as _Item?;
      i = i-1;
    }
    return new _Item?();
  }
}

private Searcher _new () {
  return new Searcher(new Module[]());
}

export _new as `new\x1dSearcher`;

int _kind (_Item _) { return (_ as Item).kind; }
export _kind as `kind\x1dget\x1dItem`;
string _mod (_Item _) { return (_ as Item).mod; }
export _mod as `mod\x1dget\x1dItem`;
string _name (_Item _) { return (_ as Item).name; }
export _name as `name\x1dget\x1dItem`;
Item[] _ins (_Item _) { return (_ as Item).ins; }
export _ins as `ins\x1dget\x1dItem`;
Item[] _outs (_Item _) { return (_ as Item).outs; }
export _outs as `outs\x1dget\x1dItem`;

void main () {
  Searcher search = _new();
  search.insert("search");
  Module mod = search.list[0];
  println("module '" + mod.name + "'");

  iterator iter = newIter(mod.map);
  MapPair? next = iter.next();
  while (!next.isnull()) {
    MapPair pair = next.get();
    string k = pair.k;
    Item item = pair.v;
    if (item.kind == 1) {
      println("type " + k + " = " + item.tostr());
    }
    if (item.kind == 2) {
      string outs = "void";

      int i = 0;
      while (i < item.outs.len()) {
        Item t = item.outs[i] as Item;
        if (i == 0) outs = t.tostr();
        else outs = outs + ", " + t.tostr();
        i = i+1;
      }

      string ins = "";

      int i = 0;
      while (i < item.ins.len()) {
        Item t = item.ins[i] as Item;
        if (i == 0) ins = t.tostr();
        else ins = ins + ", " + t.tostr();
        i = i+1;
      }

      println(outs + " " + item.mod + "." + item.name + "(" + ins + ")");
    }
    next = iter.next();
  }
}

void test_function (int n) {}
