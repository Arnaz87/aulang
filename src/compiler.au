import auro.system { void error(string); }

import aulang.node {
  type Node as Node {
    string tp;
    string val;
    int line;

    int len ();
    Node child (int);

    string to_string ();
  }
}

import aulang.parser { Node parse (string); }

import auro.buffer { type buffer; }
import aulang.writer {
  type Writer {
    new ();
    void byte (int);
    void num (int);
    void str (string);
    void rawstr (string);
    buffer tobuffer ();
  }
}

import aulang.search {
  type Item as SearchItem {
    int kind;
    string mod;
    string name;
    int inlen();
    int outlen();
    SearchItem in (int);
    SearchItem out (int);
  }

  type Searcher {
    new ();
    void insert (string module_name);
    SearchItem? get (string);
  }
}

import aulang.item {
  type Item {
    new (string tp, Node node);
    string tp;
    Node node;
    any value;
    string to_str();
  }
}

import aulang.codegen {
  string inst_name (any);
  any[] compile_function (Node root);

  type CallInst {
    any fn;
    int ins_len ();
    int outs_len ();
    int in (int i);
    int out (int i);
    Node node;
  }

  type RetInst {
    int vals_len ();
    int val (int i);
    Node node;
  }
}

// =============================== //
//               Types             //
// =============================== //

import auro.utils.stringmap (any) {
  type `` as Map {
    new ();
    any? get (string);
    void set (string, any);
  }
}

struct Pair { string k; any v; }
import auro.utils.arraylist (Pair) {
  type `` as `Pair[]` {
    new ();
    int len();
    Pair get (int);
    void push (Pair);
  }
}

struct Imported {
  Module mod;
  string name;
}

struct Module {
  int id;
  string kind;
  string name;
  any base;
  any argument;
  Pair[] items;
  int line;
  bool generic;

  void set (Module this, string k, any v) {
    this.items.push(new Pair(k, v));
  }
}

struct Type {
  int id;
  string name;
  any mod;
}

struct Function {
  int id;
  string name;
  any mod;
  any[] ins;
  any[] outs;
  any[]? code;
}

struct Import {
  any mod;
  Map items;
}

struct GenericArg { string name; }

import auro.utils.arraylist (Module) {
  type `` as `Module[]` {
    new ();
    int len();
    Module get (int);
    void set (int, Module);
    void push (Module);
    void remove (int);
  }
}

import auro.utils.arraylist (Type) {
  type `` as `Type[]` {
    new ();
    int len();
    Type get (int);
    void push (Type);
    void remove (int);
  }
}

import auro.utils.arraylist (Function) {
  type `` as `Function[]` {
    new ();
    int len();
    Function get (int);
    void push (Function);
    void remove (int);
  }
}

import auro.utils.arraylist (any) {
  type `` as `any[]` {
    new ();
    int len();
    any get (int);
    void push (any);
  }
}

import auro.utils.arraylist (Item) {
  type `` as `Item[]` {
    new ();
    int len();
    Item get (int);
    void push (Item);
  }
}

struct Compiler {
  string filename;
  Node program;
  Map items;
  Writer writer;

  Module[] modules;
  Type[] types;
  Function[] functions;

  Map imports;
  any exported;

  Searcher search;

  Item[] all_items;

  any getSearchItem (Compiler this, SearchItem it) {
    Import mod;
    any? maybe = this.imports[it.mod];

    if (maybe.isnull()) {
      Module m = this.Module();
      m.kind = "import";
      m.name = it.mod;
      mod = new Import(m as any, new Map());
      this.imports[it.mod] = mod as any;
    } else { mod = maybe.get() as Import; }

    maybe = mod.items[it.name];
    if (maybe.isnull()) {
      any a;

      if (it.kind == 1) {
        a = this.Type(it.name, mod.mod) as any;
      }

      if (it.kind == 2) {
        Function f = this.Function();
        f.name = it.name;
        f.mod = mod.mod;

        int i = 0;
        while (i < it.inlen()) {
          f.ins.push(this.getSearchItem(it.in(i)));
          i = i+1;
        }

        int i = 0;
        while (i < it.outlen()) {
          f.outs.push(this.getSearchItem(it.out(i)));
          i = i+1;
        }

        a = f as any;
      }

      mod.items[it.name] = a;
      return a;
    } else { return maybe.get(); }
  }

  any? getFromNode (Compiler this, Node node) {
    if (node.tp == "field") {
      Item modItem = new Item("module", node.child(0));
      Module mod = this.getItem(modItem as any) as Module;
      Imported imp = new Imported(mod, node.val);

      return (imp as any) as any?;
    } else if ((node.tp == "item") || (node.tp == "var")) {
      any? a = this.items[node.val];
      if (!a.isnull()) return a;

      SearchItem? it = this.search[node.val];
      if (!it.isnull()) return this.getSearchItem(it.get()) as any?;

      return new any?();
    } else if (node.tp == "generic") {
      return get_generic_node(this, node) as any?;
    } else if (node.tp == "generic_arg") {
      this.error("Generic argument out of context", node.line);
    } else {
      this.error("Unsupported item " + node.tp, node.line);
    }
  }

  // get items including generic
  any _getItem (Compiler this, any a) {
    if (a is Item) {
      Item item = a as Item;

      if (!(item.value is bool)) return item.value;

      any? _a = this.getFromNode(item.node);
      if (_a.isnull()) this.error(item.to_str() + " not found", item.node.line);
      a = _a.get();

      if ((item.node.tp == "item") && (item.node.val == "string")) {
        Type m = a as Type;
      }

      if (a is Imported) {
        Imported imp = a as Imported;
        if (item.tp == "type") a = this.Type(imp.name, imp.mod as any) as any;
        else this.error("Cannot import " + item.to_str(), item.node.line);
      }

      item.value = a;

      string atp = "unknown";
      if (a is Module) atp = "module";
      if (a is Type) atp = "type";
      if (a is Function) atp = "function";
      if ((item.tp == atp) || ((item.tp == "item") && !(atp == "unknown"))) return a;
      this.error(item.node.to_string() + " is a " + atp, item.node.line);
    }
    return a;
  }

  // get items filtering generic
  any getItem (Compiler this, any _a) {
    any a = this._getItem(_a);

    if (a is Type && (this.getItem((a as Type).mod) as Module).generic) {
      Item it = _a as Item;
      this.error(it.to_str() + " is generic", it.node.line);
    }

    if (a is Function) {
      Function f = a as Function;
      if (f.code.isnull() && (this.getItem(f.mod) as Module).generic) {
        Item it = _a as Item;
        this.error(it.to_str() + " is generic", it.node.line);
      }
    }

    return a;
  }

  Module Module (Compiler this) {
    Module mod = new Module(this.modules.len() + 1, "", "", false as any, false as any, new Pair[](), 0, false);
    this.modules.push(mod);
    return mod;
  }

  Type Type (Compiler this, string name, any mod) {
    Type t = new Type(this.types.len(), name, mod);
    this.types.push(t);
    return t;
  }

  Function Function (Compiler this) {
    Function f = new Function(this.functions.len(), "", false as any, new any[](), new any[](), new any[]?());
    this.functions.push(f);
    return f;
  }

  Item Item (Compiler this, string tp, Node node) {
    Item it = new Item(tp, node);
    this.all_items.push(it);
    return it;
  }

  void error (Compiler this, string msg, int line) {
    error(msg + ", at " + this.filename + " at line " + itos(line));
  }
}


// =============================== //
//             Generics            //
// =============================== //

any get_generic_node (Compiler this, Node node) {
  Item base_item = new Item("item", node.child(0));
  any base_any = this._getItem(base_item as any);

  if (base_any is Type) {
    Type base = base_any as Type;

    Module base_mod = this.getItem(base.mod) as Module;
    Module mod = get_generic_module(this, base_mod, node);

    Type t = this.Type(node.val, mod as any);
    return t as any;
  } else if (base_any is Function) {

    Function base = base_any as Function;

    Module base_mod = this.getItem(base.mod) as Module;
    Module mod = get_generic_module(this, base_mod, node);

    Function f = this.Function();
    f.name = base.name;
    f.mod = mod as any;

    int i = 0;
    while (i < base.ins.len()) {
      f.ins.push(get_item_as_generic(this, base.ins[i], node));
      i = i+1;
    }

    int i = 0;
    while (i < base.outs.len()) {
      f.outs.push(get_item_as_generic(this, base.outs[i], node));
      i = i+1;
    }

    //error("TODO: get types in signature as generics in the same scope as the function");
    return f as any;
  } else this.error("???", node.line);
}

any get_item_as_generic (Compiler this, any a, Node node) {
  if (!(a is GenericArg)) return this.getItem(a);

  string name = (a as GenericArg).name;

  int j = 1;
  while (j < node.len()) {
    Node inode = node.child(j);
    string alias = inode.val;

    if (alias == name) {
      return this.Item("item", inode.child(0)) as any;
    }
    j = j+1;
  }

  this.error("No generic argument: " + name, node.line);
}

Module get_generic_module (Compiler this, Module base, Node node) {
  if (!base.generic)
    this.error(node.to_string() + " is not generic", node.line);

  // TODO: Make some way of sharing argument modules between generic instatiations
  Module arg_mod = this.Module();
  arg_mod.kind = "define";
  arg_mod.line = node.line;

  int j = 1;
  while (j < node.len()) {
    Node inode = node.child(j);
    string alias = inode.val;

    any item = this.Item("item", inode.child(0)) as any;
    arg_mod[alias] = item;
    j = j+1;
  }


  Module mod = this.Module();
  mod.kind = "build";
  mod.base = base as any;
  mod.argument = arg_mod as any;

  return mod;
}



// =============================== //
//             Compiler            //
// =============================== //

void transform_instructions (Compiler this, Function f) {
  any[] code = f.code.get();

  int j = 0;
  while (j < code.len()) {
    any inst = code[j];

    if (inst is CallInst) {
      CallInst call = inst as CallInst;

      Item it = call.fn as Item;
      Function fn = this.getItem(it as any) as Function;

      call.fn = fn as any;
      
      if (!(call.ins_len() == fn.ins.len())) {
        this.error(
          it.to_str() + " expects " +
          itos(fn.ins.len()) + " arguments, but " +
          itos(call.ins_len()) + " were given",
          call.node.line
        );
      }
    }

    if (inst is RetInst) {
      RetInst ret = inst as RetInst;
      if (!(f.outs.len() == ret.vals_len())) {
        this.error("Function returns " + itos(f.outs.len()) + " values", ret.node.line);
      }
    }

    j = j+1;
  }
}

buffer compile (Node program, string filename) {
  Compiler c = new Compiler (
    filename, program,
    new Map(), new Writer(),
    new Module[](), new Type[](), new Function[](),
    new Map(), false as any, new Searcher(), new Item[]()
  );
  Module exported = c.Module(); // First module is the exported module
  exported.kind = "define";

  int i = 0;
  while (i < c.program.len()) {
    Node node = c.program.child(i);
    i = i+1;

    if (node.tp == "module-assign") {
      Module mod = c.Module();
      mod.line = node.line;
      c.items[node.val] = mod as any;

      Node vnode = node.child(0);

      if (vnode.tp == "import") {
        mod.kind = "import";
        mod.name = vnode.val;
        //c.imports[mod.name] = new Import(mod as any, new Map());
      }
      else c.error(vnode.tp + " module expression", vnode.line);

      if ((node.len() > 1) && (node.child(1).tp == "generic"))
        mod.generic = true;
    }

    else if (node.tp == "import") {
      c.search.insert(node.val);
    }

    else if (node.tp == "module-def") {
      Module mod = c.Module();
      mod.kind = "define";
      mod.line = node.line;
      c.items[node.val] = mod as any;

      int j = 0;
      while (j < node.len()) {
        Node inode = node.child(j);
        string alias = inode.val;

        any item = c.Item("item", inode.child(0)) as any;
        mod[alias] = item;
        j = j+1;
      }
    }

    else if (node.tp == "type-assign") {
      Node def = node.child(0);

      if (!(def.tp == "field"))
        c.error("Invalid type definition: " + def.to_string(), node.line);

      Type t = c.Type(def.val, c.Item("module", def.child(0)) as any);
      c.items[node.val] = t as any;
    }

    else if (node.tp == "function") {
      Function f = c.Function();

      Node in_node = node.child(0);
      int i = 0;
      while (i < in_node.len()) {
        Node t_node = in_node.child(i).child(0);

        any t_any;
        if (t_node.tp == "generic_arg")
          t_any = new GenericArg(t_node.val) as any;
        else t_any = c.Item("type", t_node) as any;

        f.ins.push(t_any);
        i = i+1;
      }

      Node out_node = node.child(1);
      int i = 0;
      while (i < out_node.len()) {
        Node t_node = out_node.child(i);

        any t_any;
        if (t_node.tp == "generic_arg")
          t_any = new GenericArg(t_node.val) as any;
        else t_any = c.Item("type", t_node) as any;

        f.outs.push(t_any);
        i = i+1;
      }

      Node body = node.child(3);

      if (body.tp == "field") {
        f.name = body.val;
        f.mod = c.Item("module", body.child(0)) as any;
      } else if (body.tp == "block") {
        f.code = compile_function(body) as any[]?;
      } else {
        c.error("Currently only imported functions are supported", node.line);
      }

      c.items[node.val] = f as any;
    }

    else if (node.tp == "export") {
      node child = node.child(0);
      if (exported.items.len() > 0)
        c.error("Export overrides public items", node.line);
      if (!(c.exported is bool))
        c.error("Export overrides previous export", node.line);

      c.exported = c.Item("module", child) as any;
    }
  }

  // Define export
  if (!(c.exported is bool)) {
    Module mod = c.getItem(c.exported) as Module;
    c.modules[0] = mod;
    int i = mod.id - 1;
    c.modules.remove(i);
    mod.id = 0;
    while (i < c.modules.len()) {
      c.modules[i].id = i+1;
      i = i+1;
    }
  }

  // Transform function instructions
  int i = 0;
  while (i < c.functions.len()) {
    Function f = c.functions[i];
    if (!f.code.isnull())
      transform_instructions(c, f);
    i = i+1;
  }

  // Force all items resolutions
  int i = 0;
  while (i < c.all_items.len()) {
    c.getItem(c.all_items[i] as any);
    i = i+1;
  }

  // Remove generic types
  int i = 0;
  while (i < c.types.len()) {
    Type t = c.types[i];
    t.id = i;
    Module m = c.getItem(t.mod) as Module;
    if (m.generic) c.types.remove(i);
    else i = i+1;
  }

  // Remove generic functions
  int i = 0;
  while (i < c.functions.len()) {
    Function f = c.functions[i];
    f.id = i;
    if (f.code.isnull()) {
      Module m = c.getItem(f.mod) as Module;
      if (m.generic) c.functions.remove(i);
      else i = i+1;
    } else i = i+1;
  }

  return getBuffer(c);
}

// =============================== //
//              Writer             //
// =============================== //

void writeModules (Compiler c) {
  Writer w = c.writer;
  Module[] mods = c.modules;

  w.num(mods.len());

  int i = 0;
  while (i < mods.len()) {
    Module mod = mods[i];
    i = i+1;
    if (mod.kind == "import") {
      w.byte(1);
      w.str(mod.name);
    } else if (mod.kind == "define") {
      w.byte(2);
      w.num(mod.items.len());
      int j = 0;
      while (j < mod.items.len()) {
        Pair p = mod.items[j];
        any item = c.getItem(p.v);
        int k, id;
        if (item is Module) {
          k = 0; id = (item as Module).id;
        } else if (item is Type) {
          k = 1; id = (item as Type).id;
        } else if (item is Function) {
          k = 2; id = (item as Function).id;
        } else error("???");
        w.byte(k);
        w.num(id);
        w.str(p.k);
        j = j+1;
      }
    } else if (mod.kind == "build") {
      w.byte(4);
      Module base = c.getItem(mod.base) as Module;
      Module arg = c.getItem(mod.argument) as Module;
      w.num(base.id);
      w.num(arg.id);
    }
    else error("What am i doing?");
  }
}

void writeTypes (Compiler c) {
  Writer w = c.writer;

  w.num(c.types.len());

  int i = 0;
  while (i < c.types.len()) {
    Type t = c.types[i];
    i = i+1;
    Module mod = c.getItem(t.mod) as Module;
    w.num(mod.id + 1);
    w.str(t.name);
  }
}

void writeFunctions (Compiler c) {
  Writer w = c.writer;

  w.num(c.functions.len());

  int codes = 0;

  Function[] code_functions = new Function[]();

  int i = 0;
  while (i < c.functions.len()) {
    Function f = c.functions[i];
    i = i+1;
    if (f.code.isnull()) {
      Module mod = c.getItem(f.mod) as Module;
      w.num(mod.id + 2);
    } else {
      w.byte(1);
    }

    int j = 0;
    int inc = f.ins.len();
    w.num(inc);
    while (j < inc) {
      w.num((c.getItem(f.ins[j]) as Type).id);
      j = j+1;
    }

    int j = 0;
    int outc = f.outs.len();
    w.num(outc);
    while (j < outc) {
      w.num((c.getItem(f.outs[j]) as Type).id);
      j = j+1;
    }

    if (f.code.isnull()) {
      w.str(f.name);
    } else {
      code_functions.push(f);
    }
  }
}

void writeCode (Compiler c) {
  Writer w = c.writer;
  
  int i = 0;
  while (i < c.functions.len()) {
    Function f = c.functions[i];
    if (f.code.isnull()) goto skip;

    any[] code = f.code.get();

    w.num(code.len());

    int j = 0;
    while (j < code.len()) {
      any inst = code[j];

      if (inst is CallInst) {

        CallInst call = inst as CallInst;
        Function fn = call.fn as Function;

        w.num(fn.id + 16);

        int k = 0;
        while (k < call.ins_len()) {
          w.num(call.in(k));
          k = k+1;
        }

      } else if (inst is RetInst) {
        RetInst ret = inst as RetInst;

        w.byte(0);
        int k = 0;
        while (k < ret.vals_len()) {
          w.num(ret.val(k));
          k = k+1;
        }
      } else error("Unsupported instruction: " + inst_name(inst));

      j = j+1;
    }

    skip:
    i = i+1;
  }
}

buffer getBuffer (Compiler c) {
  Writer w = c.writer;

  w.rawstr("Auro 0.6");
  w.byte(0);

  writeModules(c);
  writeTypes(c);
  writeFunctions(c);
  w.num(0); // Constants
  writeCode(c);
  w.num(0); // Metadata

  return w.tobuffer();
}

// =============================== //
//             Interface           //
// =============================== //

import auro.io {
  type file;
  type mode as filemode;
  filemode w ();
  file open (string, filemode);
  void write (file, buffer);
}

import aulang.util { string readall (string); }

void main () {
  string src = readall("test.au");
  buffer buf = compile(parse(src), "test.au");
  file f = open("out", w());
  write(f, buf);
}