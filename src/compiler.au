import auro.system { void error(string); }

import aulang.node {
  type Node as Node {
    string tp;
    string val;
    int line;

    int len ();
    Node child (int);
  }
}

import aulang.parser { Node parse (string); }

import auro.buffer { type buffer; }
import aulang.writer {
  type Writer {
    new ();
    void byte (int);
    void num (int);
    void str (string);
    void rawstr (string);
    buffer tobuffer ();
  }
}

import aulang.search {
  type Item as SearchItem {
    int kind;
    string mod;
    string name;
    int inlen();
    int outlen();
    SearchItem in (int);
    SearchItem out (int);
  }

  type Searcher {
    new ();
    void insert (string module_name);
    SearchItem? get (string);
  }
}

// =============================== //
//               Types             //
// =============================== //

import auro.utils.stringmap (any) {
  type `` as Map {
    new ();
    any? get (string);
    void set (string, any);
  }
}

struct Pair { string k; any v; }
import auro.utils.arraylist (Pair) {
  type `` as `Pair[]` {
    new ();
    int len();
    Pair get (int);
    void push (Pair);
  }
}

struct Item {
  string tp;
  string name;
  int line;
}

struct Module {
  int id;
  string kind;
  string name;
  any argument;
  Pair[] items;
  int line;

  void set (Module this, string k, any v) {
    this.items.push(new Pair(k, v));
  }
}

struct Type {
  int id;
  string name;
  any mod;
}

struct Function {
  int id;
  string name;
  any mod;
  any[] ins;
  any[] outs;
}

struct Import {
  any mod;
  Map items;
}

import auro.utils.arraylist (Module) {
  type `` as `Module[]` {
    new ();
    int len();
    Module get (int);
    void set (int, Module);
    void push (Module);
    void remove (int);
  }
}

import auro.utils.arraylist (Type) {
  type `` as `Type[]` {
    new ();
    int len();
    Type get (int);
    void push (Type);
  }
}

import auro.utils.arraylist (Function) {
  type `` as `Function[]` {
    new ();
    int len();
    Function get (int);
    void push (Function);
  }
}

import auro.utils.arraylist (any) {
  type `` as `any[]` {
    new ();
    int len();
    any get (int);
    void push (any);
  }
}

struct Compiler {
  string filename;
  Node program;
  Map items;
  Writer writer;

  Module[] modules;
  Type[] types;
  Function[] functions;

  Map imports;
  any exported;

  Searcher search;

  any getSearchItem (Compiler this, SearchItem it) {
    Import mod;
    any? maybe = this.imports[it.mod];

    if (maybe.isnull()) {
      Module m = this.Module();
      m.kind = "import";
      m.name = it.mod;
      mod = new Import(m as any, new Map());
      this.imports[it.mod] = mod as any;
    } else { mod = maybe.get() as Import; }

    maybe = mod.items[it.name];
    if (maybe.isnull()) {
      any a;

      if (it.kind == 1) {
        a = this.Type(it.name, mod.mod) as any;
      }

      if (it.kind == 2) {
        Function f = this.Function();
        f.name = it.name;
        f.mod = mod.mod;

        int i = 0;
        while (i < it.inlen()) {
          f.ins.push(this.getSearchItem(it.in(i)));
          i = i+1;
        }

        int i = 0;
        while (i < it.outlen()) {
          f.outs.push(this.getSearchItem(it.out(i)));
          i = i+1;
        }

        a = f as any;
      }

      mod.items[it.name] = a;
      return a;
    } else { return maybe.get(); }
  }

  any? _getItem (Compiler this, string name) {
    any? a = this.items[name];
    if (!a.isnull()) return a;

    SearchItem? it = this.search[name];
    if (!it.isnull()) return this.getSearchItem(it.get()) as any?;

    return new any?();
  }

  any getItem (Compiler this, any a) {
    if (a is Item) {
      Item item = a as Item;
      any? _a = this._getItem(item.name);
      if (_a.isnull()) this.error(item.tp + " " + item.name + " not found", item.line);
      a = _a.get();

      if (item.tp == "item") return a;

      string atp = "unknown";
      if (a is Module) atp = "module";
      if (a is Type) atp = "type";
      if (a is Function) atp = "function";
      if ((item.tp == atp) || (item.tp == "")) return a;
      this.error(item.name + " is a " + atp, item.line);
    }
    if (a is string) {
      error("Pure strings give unhelpful error messages");
      /*string k = a as string;
      any? _a = this.items[k];
      if (_a.isnull()) this.error(k + " not found", 0-1);
      a = _a.get();*/
    }
    return a;
  }

  Module Module (Compiler this) {
    Module mod = new Module(this.modules.len() + 1, "", "", false as any, new Pair[](), 0);
    this.modules.push(mod);
    return mod;
  }

  Type Type (Compiler this, string name, any mod) {
    Type t = new Type(this.types.len(), name, mod);
    this.types.push(t);
    return t;
  }

  Function Function (Compiler this) {
    Function f = new Function(this.functions.len(), "", false as any, new any[](), new any[]());
    this.functions.push(f);
    return f;
  }

  void error (Compiler this, string msg, int line) {
    error(msg + ", at " + this.filename + " at line " + itos(line));
  }
}

// =============================== //
//             Compiler            //
// =============================== //

buffer compile (Node program, string filename) {
  Compiler c = new Compiler (
    filename, program,
    new Map(), new Writer(),
    new Module[](), new Type[](), new Function[](),
    new Map(), false as any, new Searcher()
  );
  Module exported = c.Module(); // First module is the exported module
  exported.kind = "define";

  int i = 0;
  while (i < c.program.len()) {
    Node node = c.program.child(i);
    i = i+1;

    if (node.tp == "module-assign") {
      Module mod = c.Module();
      mod.line = node.line;
      c.items[node.val] = mod as any;

      Node vnode = node.child(0);

      if (vnode.tp == "import") {
        mod.kind = "import";
        mod.name = vnode.val;
        //c.imports[mod.name] = new Import(mod as any, new Map());
      }
      else c.error(vnode.tp + " module expression", vnode.line);
    }

    else if (node.tp == "import") {
      c.search.insert(node.val);
    }

    else if (node.tp == "module-def") {
      Module mod = c.Module();
      mod.kind = "define";
      mod.line = node.line;
      c.items[node.val] = mod as any;

      int j = 0;
      while (j < node.len()) {
        Node inode = node.child(j);
        string alias = inode.val;
        if (!(inode.child(0).tp == "item"))
          c.error("Currently only items can be exported", inode.line);
        any item = c.getItem(new Item("item", inode.child(0).val, inode.line) as any);
        mod[alias] = item;
        j = j+1;
      }
    }

    else if (node.tp == "type-assign") {
      string mod = node.child(0).val;
      string name = node.child(1).val;
      Type t = c.Type(name, new Item("module", mod, node.line) as any);
      c.items[node.val] = t as any;
    }

    else if (node.tp == "function") {
      Function f = c.Function();

      Node in_node = node.child(0);
      int i = 0;
      while (i < in_node.len()) {
        f.ins.push(new Item("type", in_node.child(i).child(0).val, node.line) as any);
        i = i+1;
      }

      Node out_node = node.child(2);
      int i = 0;
      while (i < out_node.len()) {
        f.outs.push(new Item("type", out_node.child(i).child(0).val, node.line) as any);
        i = i+1;
      }

      Node body = node.child(3);
      if ((body.tp == "item") && (body.len() == 1)) {
        f.name = body.val;
        f.mod = new Item("module", body.child(0).val, node.line) as any;
      } else c.error("Currently only imported functions are supported", node.line);

      c.items[node.val] = f as any;
    }

    else if (node.tp == "export") {
      node child = node.child(0);
      if (exported.items.len() > 0)
        c.error("Export overrides public items", node.line);
      if (!(c.exported is bool))
        c.error("Export overrides previous export", node.line);

      if (child.tp == "item") {
        c.exported = new Item("module", child.val, node.line) as any;
      } else c.error("Cannot export " + child.tp, node.line);
    }
  }

  // Define export
  if (!(c.exported is bool)) {
    Module mod = c.getItem(c.exported) as Module;
    c.modules[0] = mod;
    int i = mod.id - 1;
    c.modules.remove(i);
    mod.id = 0;
    while (i < c.modules.len()) {
      c.modules[i].id = i+1;
      i = i+1;
    }
  }

  return getBuffer(c);
}

// =============================== //
//              Writer             //
// =============================== //

void writeModules (Compiler c) {
  Writer w = c.writer;
  Module[] mods = c.modules;

  w.num(mods.len());

  int i = 0;
  while (i < mods.len()) {
    Module mod = mods[i];
    i = i+1;
    if (mod.kind == "import") {
      w.byte(1);
      w.str(mod.name);
    } else if (mod.kind == "define") {
      w.byte(2);
      w.num(mod.items.len());
      int j = 0;
      while (j < mod.items.len()) {
        Pair p = mod.items[j];
        any item = c.getItem(p.v);
        int k, id;
        if (item is Module) {
          k = 0; id = (item as Module).id;
        } else if (item is Type) {
          k = 1; id = (item as Type).id;
        } else if (p.v is Function) {
          k = 2; id = (p.v as Function).id;
        } else error("???");
        w.byte(k);
        w.num(id);
        w.str(p.k);
        j = j+1;
      }
    }
    else error("What am i doing?");
  }
}

void writeTypes (Compiler c) {
  Writer w = c.writer;

  w.num(c.types.len());

  int i = 0;
  while (i < c.types.len()) {
    Type t = c.types[i];
    i = i+1;
    Module mod = c.getItem(t.mod) as Module;
    w.num(mod.id + 1);
    w.str(t.name);
  }
}

void writeFunctions (Compiler c) {
  Writer w = c.writer;

  w.num(c.functions.len());

  int i = 0;
  while (i < c.functions.len()) {
    Function f = c.functions[i];
    i = i+1;
    Module mod = c.getItem(f.mod) as Module;
    w.num(mod.id + 2);

    int j = 0;
    int inc = f.ins.len();
    w.num(inc);
    while (j < inc) {
      w.num((c.getItem(f.ins[j]) as Type).id);
      j = j+1;
    }

    int j = 0;
    int outc = f.outs.len();
    w.num(outc);
    while (j < outc) {
      w.num((c.getItem(f.outs[j]) as Type).id);
      j = j+1;
    }

    w.str(f.name);
  }
}

buffer getBuffer (Compiler c) {
  Writer w = c.writer;

  w.rawstr("Auro 0.6");
  w.byte(0);

  writeModules(c);
  writeTypes(c);
  writeFunctions(c);
  w.num(0); // Constants
  w.num(0); // Metadata

  return w.tobuffer();
}

// =============================== //
//             Interface           //
// =============================== //

import auro.io {
  type file;
  type mode as filemode;
  filemode w ();
  file open (string, filemode);
  void write (file, buffer);
}

import aulang.util { string readall (string); }

void main () {
  string src = readall("test.au");
  buffer buf = compile(parse(src), "test.au");
  file f = open("out", w());
  write(f, buf);
}