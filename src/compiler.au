import auro.system { void error(string); }

import aulang.node {
  type Node as Node {
    string tp;
    string val;
    int line;

    int len ();
    Node child (int);
  }
}

import aulang.parser { Node parse (string); }

import auro.buffer { type buffer; }
import aulang.writer {
  type Writer {
    new ();
    void byte (int);
    void num (int);
    void str (string);
    void rawstr (string);
    buffer tobuffer ();
  }
}

import aulang.search {
  type Item as SearchItem {
    int kind;
    string mod;
    string name;
    int inlen();
    int outlen();
    SearchItem in (int);
    SearchItem out (int);
  }

  type Searcher {
    new ();
    void insert (string module_name);
    SearchItem? get (string);
  }
}

// =============================== //
//               Types             //
// =============================== //

import auro.utils.stringmap (any) {
  type `` as Map {
    new ();
    any? get (string);
    void set (string, any);
  }
}

struct Pair { string k; any v; }
import auro.utils.arraylist (Pair) {
  type `` as `Pair[]` {
    new ();
    int len();
    Pair get (int);
    void push (Pair);
  }
}

struct Item {
  string tp;
  string name;
  int line;
  Pair[] params; // generic
  any value;

  string to_str (Item this) {
    return this.tp + " " + this.name;
  }
}

struct Module {
  int id;
  string kind;
  string name;
  any argument;
  Pair[] items;
  int line;
  bool generic;

  void set (Module this, string k, any v) {
    this.items.push(new Pair(k, v));
  }
}

struct Type {
  int id;
  string name;
  any mod;
}

struct Function {
  int id;
  string name;
  any mod;
  any[] ins;
  any[] outs;
}

struct Import {
  any mod;
  Map items;
}

import auro.utils.arraylist (Module) {
  type `` as `Module[]` {
    new ();
    int len();
    Module get (int);
    void set (int, Module);
    void push (Module);
    void remove (int);
  }
}

import auro.utils.arraylist (Type) {
  type `` as `Type[]` {
    new ();
    int len();
    Type get (int);
    void push (Type);
  }
}

import auro.utils.arraylist (Function) {
  type `` as `Function[]` {
    new ();
    int len();
    Function get (int);
    void push (Function);
  }
}

import auro.utils.arraylist (any) {
  type `` as `any[]` {
    new ();
    int len();
    any get (int);
    void push (any);
  }
}

import auro.utils.arraylist (Item) {
  type `` as `Item[]` {
    new ();
    int len();
    Item get (int);
    void push (Item);
  }
}

struct Compiler {
  string filename;
  Node program;
  Map items;
  Writer writer;

  Module[] modules;
  Type[] types;
  Function[] functions;

  Map imports;
  any exported;

  Searcher search;

  Item[] all_items;

  any getSearchItem (Compiler this, SearchItem it) {
    Import mod;
    any? maybe = this.imports[it.mod];

    if (maybe.isnull()) {
      Module m = this.Module();
      m.kind = "import";
      m.name = it.mod;
      mod = new Import(m as any, new Map());
      this.imports[it.mod] = mod as any;
    } else { mod = maybe.get() as Import; }

    maybe = mod.items[it.name];
    if (maybe.isnull()) {
      any a;

      if (it.kind == 1) {
        a = this.Type(it.name, mod.mod) as any;
      }

      if (it.kind == 2) {
        Function f = this.Function();
        f.name = it.name;
        f.mod = mod.mod;

        int i = 0;
        while (i < it.inlen()) {
          f.ins.push(this.getSearchItem(it.in(i)));
          i = i+1;
        }

        int i = 0;
        while (i < it.outlen()) {
          f.outs.push(this.getSearchItem(it.out(i)));
          i = i+1;
        }

        a = f as any;
      }

      mod.items[it.name] = a;
      return a;
    } else { return maybe.get(); }
  }

  any? _getItem (Compiler this, string name) {
    any? a = this.items[name];
    if (!a.isnull()) return a;

    SearchItem? it = this.search[name];
    if (!it.isnull()) return this.getSearchItem(it.get()) as any?;

    return new any?();
  }

  any getGeneric (Compiler this, any a, Item item) {
    if (a is Type) {
      Type t = a as Type;
      if ((this.getItem(t.mod) as Module).generic) {
        this.error(item.to_str() + " is generic", item.line);
      } else {
        return a;
      }
    }
    return a;
  }

  any getItem (Compiler this, any a) {
    if (a is Item) {
      Item item = a as Item;
      if (!(item.value is bool)) return item.value;

      any? _a = this._getItem(item.name);
      if (_a.isnull()) this.error(item.to_str() + " not found", item.line);
      a = _a.get();

      a = this.getGeneric(a, item);

      string atp = "unknown";
      if (a is Module) atp = "module";
      if (a is Type) atp = "type";
      if (a is Function) atp = "function";
      if ((item.tp == atp) || ((item.tp == "item") && !(atp == "unknown"))) return a;
      this.error(item.name + " is a " + atp, item.line);
    }
    if (a is string) {
      error("Pure strings give unhelpful error messages");
      /*string k = a as string;
      any? _a = this.items[k];
      if (_a.isnull()) this.error(k + " not found", 0-1);
      a = _a.get();*/
    }
    return a;
  }

  Module Module (Compiler this) {
    Module mod = new Module(this.modules.len() + 1, "", "", false as any, new Pair[](), 0, false);
    this.modules.push(mod);
    return mod;
  }

  Type Type (Compiler this, string name, any mod) {
    Type t = new Type(this.types.len(), name, mod);
    this.types.push(t);
    return t;
  }

  Function Function (Compiler this) {
    Function f = new Function(this.functions.len(), "", false as any, new any[](), new any[]());
    this.functions.push(f);
    return f;
  }

  Item Item (Compiler this, string tp, string name, int line) {
    Item it = new Item(tp, name, line, new Pair[](), false as any);
    this.all_items.push(it);
    return it;
  }

  void error (Compiler this, string msg, int line) {
    error(msg + ", at " + this.filename + " at line " + itos(line));
  }
}

// =============================== //
//             Compiler            //
// =============================== //

any _resolveItem (Compiler c, any a) { return resolveItem(c, a); }

any resolveItem (Compiler c, any a) {
  if (a is Item) {
    Item item = a as Item;
    if (!(item.value is bool)) return item.value;
  }
  any value = c.getItem(a);
  if (value is Type) {
    _resolveItem(c, (value as Type).mod);
  } else if (value is Function) {
    Function f = value as Function;
    _resolveItem(c, f.mod);
    int i = 0;
    while (i < f.ins.len()) {
      _resolveItem(c, f.ins[i]);
      i = i+1;
    }
    int i = 0;
    while (i < f.outs.len()) {
      _resolveItem(c, f.outs[i]);
      i = i+1;
    }
  } else if (value is Module) {
    Module m = value as Module;
    if (m.kind == "define") {
      int i = 0;
      while (i < m.items.len()) {
        _resolveItem(c, m.items[i].v);
        i = i+1;
      }
    }
  }
  if (a is Item) (a as Item).value = value;
  return value;
}

any compileItem (Compiler c, Node node) {
  if (node.tp == "item") {
    return c.Item("item", node.val, node.line) as any;
  } else c.error(node.tp + " items not supported", node.line);
}

buffer compile (Node program, string filename) {
  Compiler c = new Compiler (
    filename, program,
    new Map(), new Writer(),
    new Module[](), new Type[](), new Function[](),
    new Map(), false as any, new Searcher(), new Item[]()
  );
  Module exported = c.Module(); // First module is the exported module
  exported.kind = "define";

  int i = 0;
  while (i < c.program.len()) {
    Node node = c.program.child(i);
    i = i+1;

    if (node.tp == "module-assign") {
      Module mod = c.Module();
      mod.line = node.line;
      c.items[node.val] = mod as any;

      Node vnode = node.child(0);

      if (vnode.tp == "import") {
        mod.kind = "import";
        mod.name = vnode.val;
        //c.imports[mod.name] = new Import(mod as any, new Map());
      }
      else c.error(vnode.tp + " module expression", vnode.line);

      if ((node.len() > 1) && (node.child(1).tp == "generic"))
        mod.generic = true;
    }

    else if (node.tp == "import") {
      c.search.insert(node.val);
    }

    else if (node.tp == "module-def") {
      Module mod = c.Module();
      mod.kind = "define";
      mod.line = node.line;
      c.items[node.val] = mod as any;

      int j = 0;
      while (j < node.len()) {
        Node inode = node.child(j);
        string alias = inode.val;
        // TODO: Can't use future items in module definition items
        any item = compileItem(c, inode.child(0));
        mod[alias] = item;
        j = j+1;
      }
    }

    else if (node.tp == "type-assign") {
      string mod = node.child(0).val;
      string name = node.child(1).val;
      Type t = c.Type(name, c.Item("module", mod, node.line) as any);
      c.items[node.val] = t as any;
    }

    else if (node.tp == "function") {
      Function f = c.Function();

      Node in_node = node.child(0);
      int i = 0;
      while (i < in_node.len()) {
        f.ins.push(c.Item("type", in_node.child(i).child(0).val, node.line) as any);
        i = i+1;
      }

      Node out_node = node.child(2);
      int i = 0;
      while (i < out_node.len()) {
        f.outs.push(c.Item("type", out_node.child(i).child(0).val, node.line) as any);
        i = i+1;
      }

      Node body = node.child(3);
      if ((body.tp == "item") && (body.len() == 1)) {
        f.name = body.val;
        f.mod = c.Item("module", body.child(0).val, node.line) as any;
      } else c.error("Currently only imported functions are supported", node.line);

      c.items[node.val] = f as any;
    }

    else if (node.tp == "export") {
      node child = node.child(0);
      if (exported.items.len() > 0)
        c.error("Export overrides public items", node.line);
      if (!(c.exported is bool))
        c.error("Export overrides previous export", node.line);

      if (child.tp == "item") {
        c.exported = c.Item("module", child.val, node.line) as any;
      } else c.error("Cannot export " + child.tp, node.line);
    }
  }

  // Define export
  if (!(c.exported is bool)) {
    Module mod = c.getItem(c.exported) as Module;
    c.modules[0] = mod;
    int i = mod.id - 1;
    c.modules.remove(i);
    mod.id = 0;
    while (i < c.modules.len()) {
      c.modules[i].id = i+1;
      i = i+1;
    }
  }

  int i = 0;
  while (i < c.all_items.len()) {
    resolveItem(c, c.all_items[i] as any);
    i = i+1;
  }

  return getBuffer(c);
}

// =============================== //
//              Writer             //
// =============================== //

void writeModules (Compiler c) {
  Writer w = c.writer;
  Module[] mods = c.modules;

  w.num(mods.len());

  int i = 0;
  while (i < mods.len()) {
    Module mod = mods[i];
    i = i+1;
    if (mod.kind == "import") {
      w.byte(1);
      w.str(mod.name);
    } else if (mod.kind == "define") {
      w.byte(2);
      w.num(mod.items.len());
      int j = 0;
      while (j < mod.items.len()) {
        Pair p = mod.items[j];
        any item = c.getItem(p.v);
        int k, id;
        if (item is Module) {
          k = 0; id = (item as Module).id;
        } else if (item is Type) {
          k = 1; id = (item as Type).id;
        } else if (item is Function) {
          k = 2; id = (item as Function).id;
        } else error("???");
        w.byte(k);
        w.num(id);
        w.str(p.k);
        j = j+1;
      }
    }
    else error("What am i doing?");
  }
}

void writeTypes (Compiler c) {
  Writer w = c.writer;

  w.num(c.types.len());

  int i = 0;
  while (i < c.types.len()) {
    Type t = c.types[i];
    i = i+1;
    Module mod = c.getItem(t.mod) as Module;
    w.num(mod.id + 1);
    w.str(t.name);
  }
}

void writeFunctions (Compiler c) {
  Writer w = c.writer;

  w.num(c.functions.len());

  int i = 0;
  while (i < c.functions.len()) {
    Function f = c.functions[i];
    i = i+1;
    Module mod = c.getItem(f.mod) as Module;
    w.num(mod.id + 2);

    int j = 0;
    int inc = f.ins.len();
    w.num(inc);
    while (j < inc) {
      w.num((c.getItem(f.ins[j]) as Type).id);
      j = j+1;
    }

    int j = 0;
    int outc = f.outs.len();
    w.num(outc);
    while (j < outc) {
      w.num((c.getItem(f.outs[j]) as Type).id);
      j = j+1;
    }

    w.str(f.name);
  }
}

buffer getBuffer (Compiler c) {
  Writer w = c.writer;

  w.rawstr("Auro 0.6");
  w.byte(0);

  writeModules(c);
  writeTypes(c);
  writeFunctions(c);
  w.num(0); // Constants
  w.num(0); // Metadata

  return w.tobuffer();
}

// =============================== //
//             Interface           //
// =============================== //

import auro.io {
  type file;
  type mode as filemode;
  filemode w ();
  file open (string, filemode);
  void write (file, buffer);
}

import aulang.util { string readall (string); }

void main () {
  string src = readall("test.au");
  buffer buf = compile(parse(src), "test.au");
  file f = open("out", w());
  write(f, buf);
}