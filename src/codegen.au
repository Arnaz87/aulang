
// TODO: Use compiler error message
import auro.system { void error(string); }

import aulang.node {
  type Node as Node {
    string tp;
    string val;
    int line;

    int len ();
    Node child (int);

    string to_string ();
  }
}

import aulang.item {
  type Item {
    new (string tp, Node node);
    string tp;
    Node node;
    any value;
    string to_str();
  }
}

struct Register {
  int id;
  string name;
}
Register newReg (string name) { return new Register(0-1, name); }

struct CallInst {
  any fn;
  Register[] ins;
  Register[] outs;
  Node node;

  int ins_len (CallInst this) { return this.ins.len(); }
  int outs_len (CallInst this) { return this.outs.len(); }
  Register in (CallInst this, int i) { return this.ins[i]; }
  Register out (CallInst this, int i) { return this.outs[i]; }
}

struct RetInst {
  Register[] vals;
  Node node;

  int vals_len (RetInst this) { return this.vals.len(); }
  Register val (RetInst this, int i) { return this.vals[i]; }
}

string inst_name (any x) {
  if (x is CallInst) return "CallInst";
  if (x is RetInst) return "RetInst";

  bool b = x as bool; // Trigger implementation specific error message
  error("Unknown instruction type");
}

import auro.utils.arraylist (any) {
  type `` as AnyList {
    new ();
    int len();
    any get (int);
    void push (any);
  }
}

struct Scope {
  AnyList code;
  ScopeBox? parent;
}
type ScopeBox (Scope);

Register compile_expr (Scope s, Node node) {
  if (node.tp == "call") {
    Register out = newReg("");
    Register outs = new Register[]();
    outs.push(out);
    compile_call(s, node, outs);
    return out;
  }
  error("Expressions not yet supported");
}

Register[] compile_expr_list (Scope s, Node node) {
  Register[] result = new Register[]();
  int i = 0;
  while (i < node.len()) {
    result.push(compile_expr(s, node.child(i)));
    i = i+1;
  }
  return result;
}

void compile_call (Scope s, Node node, Register[] outs) {
  Item fn = new Item("function", node.child(0));
  Register[] ins = compile_expr_list(s, node.child(1));
  CallInst inst = new CallInst(fn as any, ins, outs, node);
  s.code.push(inst as any);
}

void compile_stmt (Scope s, Node node) {

  if (node.tp == "block") {

    Scope inner = new Scope(s.code, s as ScopeBox as ScopeBox?);

    int i = 0;
    while (i < node.len()) {
      compile_stmt(inner, node.child(i));
      i = i+1;
    }
    return;
  }

  if (node.tp == "call") {
    compile_call(s, node, new Register[]());
    return;
  }

  if (node.tp == "return") {
    s.code.push(new RetInst(compile_expr_list(s, node.child(0)), node) as any);
    return;
  }

  error("Unknown statement: " + node.tp);
}

AnyList compile_function (Node root) {
  AnyList code = new AnyList();

  Scope scope = new Scope(code, new ScopeBox?());
  compile_stmt(scope, root);

  return code;
  /*
  // Replace eventually with fixed length arrays
  any[] result = new any[]();

  int i = 0;
  while (i < code.len()) {
    result.push(code[i]);
    i = i+1;
  }

  return result;
  */
}
