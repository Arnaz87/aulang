
// TODO: Use compiler error message
import auro.system { void error(string); }

import aulang.node {
  type Node as Node {
    string tp;
    string val;
    int line;

    int len ();
    Node child (int);

    string to_string ();
  }
}

import aulang.item {
  type Item {
    new (string tp, Node node);
    string tp;
    Node node;
    any value;
    string to_str();
  }
}

struct Register {
  int id;
  string name;
}

Register newReg (string name) { return new Register(0-1, name); }

import auro.utils.stringmap (Register) {
  type `` as RegMap {
    new ();
    Register? get (string);
    void set (string, Register);
  }
}

struct CallInst {
  any fn;
  Register[] ins;
  Register[] outs;
  Node node;

  int ins_len (CallInst this) { return this.ins.len(); }
  int outs_len (CallInst this) { return this.outs.len(); }
  Register in (CallInst this, int i) { return this.ins[i]; }
  Register out (CallInst this, int i) { return this.outs[i]; }
}

struct RetInst {
  Register[] vals;
  Node node;

  int vals_len (RetInst this) { return this.vals.len(); }
  Register val (RetInst this, int i) { return this.vals[i]; }
}

struct DupInst {
  Register in;
  Register out;
}

struct SetInst {
  Register src;
  Register dst;

  // Necessary because this struct has the same structure as Dup,
  // and aulang doesn't yet support full types
  bool dummy;
}

struct VarInst {
  Register reg;
}


string inst_name (any x) {
  if (x is CallInst) return "CallInst";
  if (x is RetInst) return "RetInst";
  if (x is DupInst) return "DupInst";
  if (x is SetInst) return "SetInst";
  if (x is VarInst) return "VarInst";

  bool b = x as bool; // Trigger implementation specific error message
  error("Unknown instruction type");
}

import auro.utils.arraylist (any) {
  type `` as AnyList {
    new ();
    int len();
    any get (int);
    void push (any);
  }
}

struct Scope {
  RegMap vars;
  AnyList code;
  ScopeBox? parent;

  void inst (Scope this, any inst) {
    this.code.push(inst);
  }

  Register get_var (Scope this, string name, Node node) {
    Register? here = this.vars[name];
    if (here.isnull()) {
      if (this.parent.isnull()) {
        error("Variable " + name + " not found");
      }
      return (this.parent.get() as Scope).get_var(name, node);
    }
    return here.get();
  }
}
type ScopeBox (Scope);

Register compile_expr (Scope s, Node node) {
  if (node.tp == "var") {
    return s.get_var(node.val, node);
  }
  if (node.tp == "call") {
    Register out = newReg("");
    Register outs = new Register[]();
    outs.push(out);
    compile_call(s, node, outs);
    return out;
  }
  error("Expressions not yet supported");
}

Register[] compile_expr_list (Scope s, Node node) {
  Register[] result = new Register[]();
  int i = 0;
  while (i < node.len()) {
    result.push(compile_expr(s, node.child(i)));
    i = i+1;
  }
  return result;
}

void compile_call (Scope s, Node node, Register[] outs) {
  Item fn = new Item("function", node.child(0));
  Register[] ins = compile_expr_list(s, node.child(1));
  s.inst(new CallInst(fn as any, ins, outs, node) as any);
}

void compile_stmt (Scope s, Node node) {

  if (node.tp == "block") {

    Scope inner = new Scope(new RegMap(), s.code, s as ScopeBox as ScopeBox?);

    int i = 0;
    while (i < node.len()) {
      compile_stmt(inner, node.child(i));
      i = i+1;
    }
    return;
  }

  if (node.tp == "decl") {
    int i = 1;
    while (i < node.len()) {
      Node part = node.child(i);
      string name = part.val;
      Register reg = newReg(name);
      if (part.len() > 0) {
        Register in = compile_expr(s, part.child(0));
        s.inst(new DupInst(in, reg) as any);
      } else {
        s.inst(new VarInst(reg) as any);
      }
      s.vars[name] = reg;
      i = i+1;
    }
    return;
  }

  if (node.tp == "assignment") {
    Node left = node.child(0);
    Node right = node.child(1);

    if (left.len() > 1) {
      error("Multiple assignments not yet supported");
    } else {
      Register src = compile_expr(s, right);
      Register dst = s.get_var(left.child(0).val, left);
      s.inst(new SetInst(src, dst, false) as any);
    }

    return;
  }

  if (node.tp == "call") {
    compile_call(s, node, new Register[]());
    return;
  }

  if (node.tp == "return") {
    s.inst(new RetInst(compile_expr_list(s, node.child(0)), node) as any);
    return;
  }

  error("Unknown statement: " + node.tp);
}

AnyList compile_function (Node root) {
  AnyList code = new AnyList();

  Scope scope = new Scope(new RegMap(), code, new ScopeBox?());
  compile_stmt(scope, root);

  return code;
}
